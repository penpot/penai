import re
import uuid
from collections.abc import Callable
from enum import Enum, StrEnum

from penai.config import get_config
from penai.llm.conversation import Conversation, Response
from penai.llm.llm_model import RegisteredLLM
from penai.svg import SVG, PenpotShapeElement

cfg = get_config()


class VariationLogicSnippet(StrEnum):
    SHAPES_COLORS_POSITIONS = (
        "Modify shapes, foreground colors and relative positioning, "
        "but stay close to the original design. "
    )


def get_default_variation_prefix(num_variations: int) -> str:
    """Returns the default prefix for prompts that create variations."""
    return f"Create {num_variations} variations of the SVG."


def get_default_variations_format_description() -> str:
    """Returns the default format description for prompts that create variations."""
    return """For each variation, create a level 2 heading (markdown prefix `## `) that names
the variation followed by the respective code snippet."""


def get_default_variations_prompt(
    num_variations: int = 5,
    variation_logic: str | VariationLogicSnippet = VariationLogicSnippet.SHAPES_COLORS_POSITIONS,
) -> str:
    """Returns the default prompt for variations."""
    prefix = get_default_variation_prefix(num_variations)
    format_description = get_default_variations_format_description()
    return f"{prefix}\n{variation_logic}\n{format_description}"


class VariationPromptFactory(Enum):
    DEFAULT = "DEFAULT"

    def get_factory(self) -> Callable[[int, str], str]:
        """Returns the default prompt factory for the variation prompt.

        The factory will map the number of variations and the variation logic to a prompt string.
        """
        match self:
            case VariationPromptFactory.DEFAULT:
                return get_default_variations_prompt
            case _:
                raise NotImplementedError(self)


def transform_generated_svg_code(svg_code: str) -> str:
    """Transforms SVG code generated by an LLM in order to remove any non-code prefixes
    and to ensure that identifiers appearing in the code are unique.

    :param svg_code: the generated SVG code
    :return: the transformed SVG code
    """
    # remove any language indication prefix (resulting from markdown "```xml")
    m = re.match(r"[^<]*", svg_code)
    if m is not None:
        svg_code = svg_code[len(m.group(0)) :]

    # replace identifiers with unique ids
    ids = re.findall(r'id="(.*?)"', svg_code)
    for identifier in ids:
        new_id = uuid.uuid1()
        svg_code = svg_code.replace(f'id="{identifier}"', f'id="{new_id}"')
        svg_code = svg_code.replace(f"url(#{identifier})", f"url(#{new_id})")

    return svg_code


class SVGVariationsResponse(Response):
    def get_variations_dict(self) -> dict[str, str]:
        return {
            k: transform_generated_svg_code(svg_code)
            for k, svg_code in self.get_code_in_sections(2).items()
        }


class SVGVariationsConversation(Conversation[SVGVariationsResponse]):
    def __init__(self, model: RegisteredLLM = RegisteredLLM.GPT4O, verbose: bool = True):
        super().__init__(model, verbose=verbose, response_factory=SVGVariationsResponse)


class SVGVariations:
    def __init__(
        self,
        original_svg: SVG,
        variations_dict: dict[str, str],
        conversation: SVGVariationsConversation,
    ):
        """:param original_svg: the original SVG
        :param variations_dict: a mapping from variation name to SVG code
        """
        self.variations_dict = variations_dict
        self.original_svg = original_svg
        self.conversation = conversation

    def to_html(self, width_style: str = "60%") -> str:
        html = "<html><body>"
        html += f'<div style="width:{width_style}">'
        html += "<h1>Variations</h1>"
        for name, svg in self.variations_dict.items():
            html += f"<h2>{name}</h2>"
            html += svg
        html += "</div>"
        html += "</body></html>"
        return html

    def revise(self, prompt: str) -> "SVGVariations":
        conversation = self.conversation.clone()
        response = conversation.query_response(prompt)
        variations_dict = response.get_variations_dict()
        return SVGVariations(self.original_svg, variations_dict, conversation)


class SVGVariationsGenerator:
    def __init__(
        self,
        shape: PenpotShapeElement,
        semantics: str,
        verbose: bool = True,
    ):
        self.semantics = semantics

        # create simplified SVG (without the bloat)
        self.svg = shape.to_svg()
        self.svg.strip_penpot_tags()
        self.verbose = verbose

    def _create_conversation(self) -> SVGVariationsConversation:
        return SVGVariationsConversation(verbose=self.verbose)

    def get_svg_refactoring_prompt(self) -> str:
        return (
            f"The semantics of the following SVG can be summarized using the term(s) '{self.semantics}'. "
            "Refactor the SVG to make the shapes that are being used explicit (where applicable), "
            "making use of the respective shape tags (rect, circle, ellipse, etc.) whenever possible. "
            "Be sure to maintain any cutouts that are present in the original SVG by using appropriate masks.\n\n"
            f"```{self.svg.to_string()}```"
        )

    def create_variations(
        self,
        num_variations: int = 5,
        variation_logic: str
        | VariationLogicSnippet = VariationLogicSnippet.SHAPES_COLORS_POSITIONS,
    ) -> SVGVariations:
        refactoring_prompt = self.get_svg_refactoring_prompt()
        logic_prompt = get_default_variations_prompt(num_variations, variation_logic)
        conversation = self._create_conversation()
        conversation.query(refactoring_prompt)

        response = conversation.query_response(logic_prompt)
        variations_dict = response.get_code_in_sections(2)
        return SVGVariations(self.svg, variations_dict, conversation)

    # TODO: we can save tokens by branching off after the refactoring query instead of resetting
    def query_free_prompt(
        self,
        prompt: str,
        include_svg_refactoring_query: bool = True,
    ) -> tuple[SVGVariationsResponse, SVGVariationsConversation]:
        conversation = self._create_conversation()
        if include_svg_refactoring_query:
            conversation.query(self.get_svg_refactoring_prompt())
        return conversation.query_response(prompt), conversation
