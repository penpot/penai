import logging
import os
import re
import uuid
from collections.abc import Callable
from enum import Enum, StrEnum
from pathlib import Path

from sensai.util.logging import datetime_tag

from penai.config import get_config
from penai.llm.conversation import Conversation, Response
from penai.llm.llm_model import RegisteredLLM
from penai.svg import SVG, PenpotShapeElement
from penai.types import PathLike

cfg = get_config()

log = logging.getLogger(__name__)


class VariationLogicSnippet(StrEnum):
    SHAPES_COLORS_POSITIONS = (
        "Modify shapes, foreground colors and relative positioning, "
        "but stay close to the original design. "
    )


def get_default_variation_prefix(num_variations: int) -> str:
    """Returns the default prefix for prompts that create variations."""
    return f"Create {num_variations} variations of the SVG."


def get_default_variations_format_description() -> str:
    """Returns the default format description for prompts that create variations."""
    return """For each variation, create a level 2 heading (markdown prefix `## `) that names
the variation followed by the respective code snippet."""


def get_default_variations_prompt(
    num_variations: int = 5,
    variation_logic: str | VariationLogicSnippet = VariationLogicSnippet.SHAPES_COLORS_POSITIONS,
) -> str:
    """Returns the default prompt for variations."""
    prefix = get_default_variation_prefix(num_variations)
    format_description = get_default_variations_format_description()
    return f"{prefix}\n{variation_logic}\n{format_description}"


class VariationPromptFactory(Enum):
    DEFAULT = "DEFAULT"

    def get_factory(self) -> Callable[[int, str], str]:
        """Returns the default prompt factory for the variation prompt.

        The factory will map the number of variations and the variation logic to a prompt string.
        """
        match self:
            case VariationPromptFactory.DEFAULT:
                return get_default_variations_prompt
            case _:
                raise NotImplementedError(self)


def transform_generated_svg_code(svg_code: str) -> str:
    """Transforms SVG code generated by an LLM in order to remove any non-code prefixes
    and to ensure that identifiers appearing in the code are unique.

    :param svg_code: the generated SVG code
    :return: the transformed SVG code
    """
    # remove any language indication prefix (resulting from markdown "```xml")
    m = re.match(r"[^<]*", svg_code)
    if m is not None:
        svg_code = svg_code[len(m.group(0)) :]

    # replace identifiers with unique ids
    ids = re.findall(r'id="(.*?)"', svg_code)
    for identifier in ids:
        new_id = uuid.uuid1()
        svg_code = svg_code.replace(f'id="{identifier}"', f'id="{new_id}"')
        svg_code = svg_code.replace(f"url(#{identifier})", f"url(#{new_id})")

    return svg_code


class SVGVariationsResponse(Response):
    def get_variations_dict(self) -> dict[str, str]:
        return {
            k: transform_generated_svg_code(svg_code)
            for k, svg_code in self.get_code_in_sections(2).items()
        }


class SVGVariationsConversation(Conversation[SVGVariationsResponse]):
    def __init__(self, model: RegisteredLLM = RegisteredLLM.GPT4O, verbose: bool = True):
        super().__init__(model, verbose=verbose, response_factory=SVGVariationsResponse)


class SVGVariations:
    def __init__(
        self,
        original_svg: SVG,
        variations_dict: dict[str, str],
        conversation: SVGVariationsConversation,
    ):
        """:param original_svg: the original SVG
        :param variations_dict: a mapping from variation name to SVG code
        """
        self.variations_dict = variations_dict
        self.original_svg = original_svg
        self.conversation = conversation

    def to_html(self, width_style: str = "60%") -> str:
        html = "<html><body>"
        html += f'<div style="width:{width_style}">'
        html += "<h1>Variations</h1>"
        for name, svg in self.variations_dict.items():
            html += f"<h2>{name}</h2>"
            html += svg
        html += "</div>"
        html += "</body></html>"
        return html

    def revise(self, prompt: str) -> "SVGVariations":
        conversation = self.conversation.clone()
        response = conversation.query_response(prompt)
        variations_dict = response.get_variations_dict()
        return SVGVariations(self.original_svg, variations_dict, conversation)


class SVGVariationsGenerator:
    def __init__(
        self,
        shape: PenpotShapeElement,
        semantics: str,
        verbose: bool = True,
        model: RegisteredLLM = RegisteredLLM.GPT4O,
        responses_persistence_basedir: PathLike = Path("log") / "llm_responses",
        responses_persistence_enabled: bool = True,
        add_timestamp_to_logged_files: bool = True,
    ):
        """:param shape:
        :param semantics:
        :param verbose:
        :param model:
        :param responses_persistence_basedir:
        :param responses_persistence_enabled: whether to save the responses to disk
        :param add_timestamp_to_logged_files: if False, iterative calls to the same method will
            overwrite previously logged files for the same model
        """
        self.semantics = semantics

        # create simplified SVG (without the bloat)
        self.svg = shape.to_svg()
        self.svg.strip_penpot_tags()
        self.verbose = verbose
        self.model = model
        self.responses_basedir = Path(responses_persistence_basedir)
        self.persistence_enabled = responses_persistence_enabled
        self.add_timestamp_to_logged_files = add_timestamp_to_logged_files

    def _get_llm_responses_logdir(self) -> Path:
        responses_dir = Path(self.responses_basedir) / self.model.value
        if self.add_timestamp_to_logged_files:
            responses_dir = responses_dir / datetime_tag()
        return responses_dir

    def _create_conversation(self) -> SVGVariationsConversation:
        return SVGVariationsConversation(verbose=self.verbose, model=self.model)

    def _write_if_logging_enabled(
        self,
        path: PathLike,
        content: str,
        content_description: str = "",
    ) -> None:
        path = Path(path)
        if self.persistence_enabled:
            os.makedirs(path.parent, exist_ok=True)
            log.info(f"Writing {content_description} to:\n{path.absolute()}")
            with open(path, "w") as f:
                f.write(content)

    def get_svg_refactoring_prompt(self) -> str:
        return (
            f"The semantics of the following SVG can be summarized using the term(s) '{self.semantics}'. "
            "Refactor the SVG to make the shapes that are being used explicit (where applicable), "
            "making use of the respective shape tags (rect, circle, ellipse, etc.) whenever possible. "
            "Be sure to maintain any cutouts that are present in the original SVG by using appropriate masks.\n\n"
            f"```{self.svg.to_string()}```"
        )

    def create_variations(
        self,
        num_variations: int = 5,
        variation_logic: str
        | VariationLogicSnippet = VariationLogicSnippet.SHAPES_COLORS_POSITIONS,
    ) -> SVGVariations:
        # all of this is unused if logging is disabled
        response_logdir = self._get_llm_responses_logdir()
        if self.persistence_enabled:
            os.makedirs(response_logdir, exist_ok=True)
        svg_refactoring_path = response_logdir / "svg_refactoring.txt"
        variations_response_md_path = response_logdir / "variations_response.md"
        variations_response_html_path = response_logdir / "variations_response.html"
        full_conversation_path = response_logdir / "full_conversation.txt"

        refactoring_prompt = self.get_svg_refactoring_prompt()
        logic_prompt = get_default_variations_prompt(num_variations, variation_logic)

        conversation = self._create_conversation()
        refactoring_response = conversation.query_text(refactoring_prompt)

        self._write_if_logging_enabled(
            svg_refactoring_path,
            refactoring_response,
            content_description="svg refactoring response",
        )

        variations_response = conversation.query_response(logic_prompt)

        self._write_if_logging_enabled(
            variations_response_md_path,
            variations_response.text,
            content_description="variations response",
        )
        self._write_if_logging_enabled(
            full_conversation_path,
            conversation.get_full_conversation_string(),
            content_description="full conversation",
        )

        variations_dict = variations_response.get_code_in_sections(2)
        variations = SVGVariations(self.svg, variations_dict, conversation)
        self._write_if_logging_enabled(
            variations_response_html_path,
            variations.to_html(),
            content_description="variations response as html",
        )
        return variations

    # TODO: we can save tokens by branching off after the refactoring query instead of resetting
    def query_free_prompt(
        self,
        prompt: str,
        include_svg_refactoring_query: bool = True,
    ) -> tuple[SVGVariationsResponse, SVGVariationsConversation]:
        conversation = self._create_conversation()
        if include_svg_refactoring_query:
            conversation.query(self.get_svg_refactoring_prompt())
        return conversation.query_response(prompt), conversation
