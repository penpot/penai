import logging
import re
import uuid
from collections.abc import Sequence
from enum import Enum, StrEnum
from pathlib import Path
from typing import Self

from sensai.util.logging import datetime_tag

from penai.config import get_config
from penai.llm.conversation import Conversation, Response
from penai.llm.llm_model import RegisteredLLM
from penai.models import PenpotColors
from penai.svg import SVG, PenpotShapeElement
from penai.types import PathLike
from penai.utils.io import ResultWriter, fn_compatible

cfg = get_config()

log = logging.getLogger(__name__)


class VariationInstructionSnippet(StrEnum):
    SHAPES_COLORS_POSITIONS = (
        "Modify shapes, foreground colors and relative positioning, "
        "but stay close to the original design."
    )
    SPECIFIC_COLORS_SHAPES = (
        "Modify border colors, foreground and background colors as well as shapes. "
        "Stay close to the original design. "
    )


REVISION_PREPROMPT = (
    "Now, you are to revise the variations you have created. "
    "For each variation, consider the following revision instruction: \n"
)


class RevisionInstructionSnippet(StrEnum):
    MODIFY_SHAPES = "Modify these variations such that they all consider shape changes."


PROMPT_FORMAT_DESCRIPTION = (
    "For each variation, create a level 2 heading (markdown prefix `## `) that names "
    "the variation followed by the respective code snippet."
)


class VariationDescriptionSequence(Enum):
    UI_ELEMENT_STATES = (
        "adapted for UI state 'active'",
        "adapted for UI state 'disabled'",
        "adapted for UI state 'error'",
    )


class VariationsPrompt:
    def __init__(self, text: str, _private: int):
        if _private != 42:
            raise ValueError(
                "This class should not be instantiated directly. Use VariationsPromptBuilder instead.",
            )
        self.text = text


class VariationsPromptBuilder:
    def __init__(self, num_variations: int | None):
        """:param num_variations: the number of variations to create; if None, the number is not specified and should be made explicit in
        customized variation instructions
        """
        num_variations_text = "" if num_variations is None else f"{num_variations} "
        self._prompt_1_create_variations = f"Create {num_variations_text}variations of the SVG."
        self._prompt_2_variation_instructions: str | VariationInstructionSnippet = (
            VariationInstructionSnippet.SHAPES_COLORS_POSITIONS
        )

    def with_variation_instructions(self, instructions: str | VariationInstructionSnippet) -> Self:
        """:param instructions: instructions on how to generate variations.
            If no number of variations is specified at construction, it should include specific instructions on which variations to generate.
        :return:
        """
        self._prompt_2_variation_instructions = instructions
        return self

    def build(self) -> VariationsPrompt:
        return VariationsPrompt(
            f"{self._prompt_1_create_variations}\n"
            f"{self._prompt_2_variation_instructions}\n"
            f"{PROMPT_FORMAT_DESCRIPTION}",
            42,
        )


def ensure_unique_ids_in_svg_code(svg_code: str) -> str:
    """Transforms SVG code generated by an LLM in order to ensure that identifiers appearing in the code are unique.

    :param svg_code: the generated SVG code
    :return: the transformed SVG code
    """
    ids = re.findall(r'id="(.*?)"', svg_code)
    for identifier in ids:
        new_id = uuid.uuid1()
        svg_code = svg_code.replace(f'id="{identifier}"', f'id="{new_id}"')
        svg_code = svg_code.replace(f"url(#{identifier})", f"url(#{new_id})")
        svg_code = svg_code.replace(f"url('#{identifier}')", f"url('#{new_id})'")
        svg_code = svg_code.replace(f'href="#{identifier}"', f'href="#{new_id}"')
    return svg_code


class SVGVariationsResponse(Response):
    def get_variations_dict(self) -> dict[str, str]:
        variations_dict = {
            k: code_snippet.code for k, code_snippet in self.get_code_in_sections(2).items()
        }
        return variations_dict


class SVGVariationsConversation(Conversation[SVGVariationsResponse]):
    def __init__(
        self,
        model: RegisteredLLM = RegisteredLLM.GPT4O,
        verbose: bool = True,
        system_prompt: str | None = None,
    ):
        super().__init__(
            model,
            verbose=verbose,
            response_factory=SVGVariationsResponse,
            system_prompt=system_prompt,
        )


class SVGVariations:
    def __init__(
        self,
        original_svg: SVG,
        variations_dict: dict[str, str],
        conversation: SVGVariationsConversation | None = None,
    ):
        """:param original_svg: the original SVG
        :param variations_dict: a mapping from variation name to SVG code
        """
        self.variations_dict = variations_dict
        self.original_svg = original_svg
        self.conversation = conversation

    def to_html(self, width_style: str = "60%") -> str:
        # NOTE: When rendering several inlined SVGs together on an HTML page,
        #       we must ensure that all identifiers are unique.
        html = "<html><body>"
        html += f'<div style="width:{width_style}">'
        html += "<h1>Original</h1>"
        html += ensure_unique_ids_in_svg_code(self.original_svg.to_string())
        html += "<h1>Variations</h1>"
        for name, svg in self.variations_dict.items():
            html += f"<h2>{name}</h2>"
            html += ensure_unique_ids_in_svg_code(svg)
        html += "</div>"
        html += "</body></html>"
        return html

    def revise(
        self,
        revision_logic: str | RevisionInstructionSnippet = RevisionInstructionSnippet.MODIFY_SHAPES,
        preprompt: str = REVISION_PREPROMPT,
    ) -> "SVGVariations":
        if self.conversation is None:
            raise ValueError("Cannot revise without a conversation")
        conversation = self.conversation.clone()
        revision_prompt = preprompt + revision_logic
        response = conversation.query(revision_prompt)
        variations_dict = response.get_variations_dict()
        return SVGVariations(self.original_svg, variations_dict, conversation)

    def write_results(self, result_writer: ResultWriter, file_prefix: str = "") -> None:
        if self.conversation is not None:
            result_writer.write_text_file(
                f"{file_prefix}full_conversation.md",
                self.conversation.get_full_conversation_string(),
                content_description="full conversation",
            )
        result_writer.write_text_file(
            f"{file_prefix}variations.html",
            self.to_html(),
            content_description="variations response as HTML",
        )
        for i, (name, svg_text) in enumerate(self.variations_dict.items(), start=1):
            result_writer.write_text_file(
                f"{file_prefix}variation_{i}.svg",
                svg_text,
                content_description=f"variation '{name}' as SVG",
            )


class SVGVariationsGenerator:
    def __init__(
        self,
        shape: PenpotShapeElement,
        semantics: str | None = None,
        verbose: bool = True,
        model: RegisteredLLM = RegisteredLLM.GPT4O,
        persistence_base_dir: PathLike = Path(cfg.results_dir()) / "svg_variations",
        persistence_enabled: bool = True,
    ):
        """:param shape:
        :param semantics:
        :param verbose:
        :param model:
        :param persistence_base_dir: the base directory for persistence, to which subdirectories indicating the shape name
            and (optionally, if `persistence_add_timestamp` is enabled) the current time will be added
        :param persistence_enabled: whether to save the responses to disk
        """
        self.semantics = semantics

        # create simplified SVG (without the bloat)
        self.svg = shape.to_svg().with_shortened_ids()
        self.svg.strip_penpot_tags()
        self.verbose = verbose
        self.model = model
        persistence_base_dir = Path(persistence_base_dir)
        result_dir = (
            persistence_base_dir / fn_compatible(shape.name) / (datetime_tag() + "_" + model.value)
        )
        self.result_writer = ResultWriter(result_dir, enabled=persistence_enabled)

    @property
    def persistence_dir(self) -> Path:
        return Path(self.result_writer.result_dir).absolute()

    def _create_conversation(self, system_prompt: str | None = None) -> SVGVariationsConversation:
        return SVGVariationsConversation(
            verbose=self.verbose, model=self.model, system_prompt=system_prompt
        )

    def get_svg_refactoring_prompt(self) -> str:
        prompt = ""
        if self.semantics is not None:
            prompt += (
                f"The semantics of the following SVG can be summarized using the term(s) '{self.semantics}'. "
                "Refactor the SVG"
            )
        else:
            prompt += "Refactor the following SVG"
        prompt += (
            " to make the shapes that are being used explicit (where applicable), "
            "making use of the respective shape tags (rect, circle, ellipse, etc.) whenever possible. "
            "Be sure to maintain any cutouts that are present in the original SVG by using appropriate masks.\n\n"
            f"```{self.svg.to_string()}```"
        )
        return prompt

    def create_variations_for_prompt(
        self,
        variations_prompt: VariationsPrompt,
    ) -> SVGVariations:
        conversation = self._create_conversation()
        conversation.query_text(self.get_svg_refactoring_prompt())

        variations_response = conversation.query(variations_prompt.text)
        variations_dict = variations_response.get_variations_dict()
        variations = SVGVariations(self.svg, variations_dict, conversation)

        variations.write_results(self.result_writer)
        return variations

    def create_variations(
        self,
        num_variations: int = 5,
        variation_logic: (
            str | VariationInstructionSnippet
        ) = VariationInstructionSnippet.SHAPES_COLORS_POSITIONS,
    ) -> SVGVariations:
        prompt = (
            VariationsPromptBuilder(num_variations)
            .with_variation_instructions(variation_logic)
            .build()
        )
        return self.create_variations_for_prompt(prompt)

    def revise_variations(
        self,
        variations: SVGVariations,
        revision_prompt: str
        | RevisionInstructionSnippet = RevisionInstructionSnippet.MODIFY_SHAPES,
    ) -> SVGVariations:
        """Generates revised variations based on the given variations. If persistence is enabled, the saved files will
        have the prefix `revised_`.
        """
        revised_variations = variations.revise(revision_prompt)
        revised_variations.write_results(self.result_writer, file_prefix="revised_")
        return revised_variations

    @classmethod
    def _create_colors_prompt(cls, penpot_colors: PenpotColors) -> str:
        colors = penpot_colors.get_colors()
        prompt = ""
        if len(colors) > 0:
            prompt += "The design uses the following colors:\n"
            for color in colors:
                prompt += f"{color.name}: {color.color}\n"
            prompt += (
                "In the SVGs you create, use these colors where applicable "
                "and make sure that any additional colors fit well with the existing color scheme."
            )
        return prompt

    @classmethod
    def _create_variation_scope_prompt(
        cls, variation_scope: VariationInstructionSnippet | str, colors: PenpotColors | None = None
    ) -> str:
        prompt = str(variation_scope)
        if colors is not None:
            colors_prompt = cls._create_colors_prompt(colors)
            if colors_prompt != "":
                prompt += "\n" + colors_prompt
        return prompt

    def create_variations_sequentially(
        self,
        variation_scope: (
            VariationInstructionSnippet | str
        ) = VariationInstructionSnippet.SPECIFIC_COLORS_SHAPES,
        variation_description_sequence: (
            VariationDescriptionSequence | Sequence[str]
        ) = VariationDescriptionSequence.UI_ELEMENT_STATES,
        colors: PenpotColors | None = None,
    ) -> SVGVariations:
        """Generates variations sequentially, one at a time, accounting for limitations in response token count
        (~4K for GPT-4o, which is not enough for multiple variations at once).

        :param variation_scope: describes the scope of variations to apply in generation
        :param variation_description_sequence: a sequence of instructions describing what to do for each variation
        :param colors: the colors used in the design, which shall be considered in the generation process
        :return: the variations
        """
        conversation = self._create_conversation()
        conversation.query(self.get_svg_refactoring_prompt())

        variation_scope_prompt = self._create_variation_scope_prompt(variation_scope, colors)

        initial_variation_query = (
            "In the following, your task is to create variations of the SVG, one variation at a time. "
            "Whenever you output a variation, prefix it with a level 2 title (markdown prefix `## `) that names the variation, "
            "followed by the respective code snippet.\n"
            "In general, you may do the following: " + variation_scope_prompt + "\n\n"
            "Here are the instructions for the first variation:\n"
        )

        variation_prompt_template = 'Create a variation corresponding to the description: "%s".'

        variation_descriptions: Sequence[str]
        if isinstance(variation_description_sequence, VariationDescriptionSequence):
            variation_descriptions = variation_description_sequence.value
        else:
            assert isinstance(variation_description_sequence, list)
            variation_descriptions = variation_description_sequence

        all_variations_dict = {}
        for i, instruction in enumerate(variation_descriptions):
            prompt = initial_variation_query if i == 0 else ""
            prompt += variation_prompt_template % instruction
            response = conversation.query(prompt)
            variations_dict = response.get_variations_dict()
            all_variations_dict.update(variations_dict)

        variations = SVGVariations(self.svg, all_variations_dict, conversation)
        variations.write_results(self.result_writer)
        return variations

    def create_variations_from_example_present_at_once(
        self,
        example_variations: SVGVariations,
        colors: PenpotColors | None = None,
    ) -> SVGVariations:
        """Generates variations based on an example set of variations that are presented to the model initially.
        Given the example variations (original, (variation_1, variation_2, ...)), the model is asked to generate,
        the same kinds of variations for another UI element - one at atime, but in a single conversation.

        :param example_variations: the example variations
        :param colors: the colors used in the design, which shall be considered in the generation process
        :return: the variations
        """
        system_prompt = (
            "You are a design assistant tasked with creating variations of an SVG. "
            "You will be presented with examples of variations of a UI element, and your task is to apply the same variation "
            "principles to another UI element. "
            "In each response you are to return a single variation. "
        )
        if colors:
            colors_prompt = self._create_colors_prompt(colors)
            if colors_prompt != "":
                system_prompt += "\n" + colors_prompt

        conversation = self._create_conversation(system_prompt=system_prompt)

        example_prompt = (
            "Here is an example of a UI element with variations:\n\n"
            f"Original design:\n```{example_variations.original_svg.to_string()}```\n\n"
        )
        for name, svg in example_variations.variations_dict.items():
            example_prompt += f"Variation '{name}':\n```{svg}```\n\n"

        initial_instruction_prompt = (
            example_prompt
            + f"This is the SVG for which are now to generate variations:\n\n```{self.svg.to_string()}```\n\n"
            "Here are the instructions for the first variation:\n"
        )

        variations_dict = {}
        for i, name in enumerate(example_variations.variations_dict.keys()):
            prompt = initial_instruction_prompt if i == 0 else ""
            prompt += f"Based on the example, create the variation '{name}'."
            response = conversation.query(prompt)
            code_snippets = response.get_code_snippets()
            if len(code_snippets) > 1:
                log.warning("Received more than one code snippet in response; using the first one")
            variations_dict[name] = code_snippets[0].code

        variations = SVGVariations(self.svg, variations_dict, conversation)
        variations.write_results(self.result_writer)
        return variations

    def create_variations_from_example(
        self,
        example_variations: SVGVariations,
        colors: PenpotColors | None = None,
    ) -> SVGVariations:
        """Generates variations based on an example set of variations that are presented to the model one
        at a time, i.e. in each conversation, the model is given one example (original, variation) and is
        asked to create the same type of variation for another UI element.

        :param example_variations: the example variations; if there are multiple variations, then there
            will be a separate conversation for each variation asking the model to create that kind of variation
        :param colors: the colors used in the design, which shall be considered in the generation process
        :return: the variations
        """
        system_prompt = (
            "You are a design assistant tasked with creating a variation of an SVG. "
            "You will be presented with an example, i.e. an original design and a variation thereof. "
            "Your task is analyze the way in which the variation differs from the original "
            "and then apply the same mechanisms to another UI element. "
        )
        if colors:
            colors_prompt = self._create_colors_prompt(colors)
            if colors_prompt != "":
                system_prompt += "\n" + colors_prompt

        variations_dict = {}
        for _i, (name, svg_text) in enumerate(example_variations.variations_dict.items()):
            conversation = self._create_conversation(system_prompt=system_prompt)
            prompt = (
                "Here is the example pair (original and variation):\n\n"
                f"This is the original design:\n```{example_variations.original_svg.to_string()}```\n\n"
                f"This is the variation '{name}':\n```{svg_text}```\n\n"
                f"Based on this example, apply the same type of variation to this design:\n```{self.svg.to_string()}```\n"
            )
            response = conversation.query(prompt)
            code_snippets = response.get_code_snippets()
            if len(code_snippets) == 0:
                log.warning(f"Received no code snippets for '{name}'")
                continue
            if len(code_snippets) > 1:
                log.warning("Received more than one code snippet in response; using the first one")
            variations_dict[name] = code_snippets[0].code

        variations = SVGVariations(self.svg, variations_dict)
        variations.write_results(self.result_writer)
        return variations
